{"version":3,"sources":["webpack:///./node_modules/codemirror/addon/dialog/dialog.js","webpack:///./node_modules/codemirror/keymap/vim.js","webpack:///./src/views/garbage/g3.vue?34e1","webpack:///./node_modules/codemirror/addon/edit/matchbrackets.js","webpack:///./src/views/garbage/g3.vue?c717","webpack:///src/views/garbage/g3.vue","webpack:///./src/views/garbage/g3.vue?0bd6","webpack:///./src/views/garbage/g3.vue","webpack:///./node_modules/codemirror/mode/markdown/markdown.js","webpack:///./node_modules/codemirror/addon/search/searchcursor.js","webpack:///./node_modules/codemirror/mode/xml/xml.js","webpack:///./node_modules/codemirror/mode/meta.js"],"names":["mod","__webpack_require__","CodeMirror","dialogDiv","cm","template","bottom","dialog","wrap","getWrapperElement","appendChild","document","createElement","className","innerHTML","addClass","closeNotification","newVal","state","currentNotificationClose","defineExtension","callback","options","this","closed","me","close","inp","value","rmClass","parentNode","removeChild","focus","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","on","e","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","callbacks","buttons","blurring","i","length","b","e_preventDefault","setTimeout","doneTimer","duration","clearTimeout","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","replace","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","setOption","signal","mode","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","vim","detachVimMap","next","keyMap","getOption","body","style","caretColor","disableFatCursorMark","attach","attachVimMap","prev","enableFatCursorMark","updateFatCursorMark","fatCursorMarks","clearFatCursorMark","ranges","listSelections","result","range","empty","anchor","ch","getLine","line","push","markText","widget","textContent","setBookmark","marks","clear","cmKey","key","vimKey","cmKeyToVimKey","cmd","findKey","defineOption","val","Init","test","modifiers","Shift","Ctrl","Alt","Cmd","Mod","specialKeys","Enter","Backspace","Delete","Insert","charAt","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","undefined","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","prototype","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","substr","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","slice","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","match","exec","substring","index","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","selections","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","operation","curOp","isVimOp","processCommand","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","dir","element","pushInput","splice","reset","bestMatch","matches","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","shift","handleQuery","showPrompt","onPromptClose","desc","searchPromptDesc","onPromptKeyUp","onPromptKeyDown","word","expandWordUnderCursor","isKeyword","end","escapeRegex","ignoreCase","smartCase","updateSearchQuery","showConfirm","scrollTo","left","top","logSearchQuery","parsedQuery","keyName","target","selectionEnd","selectionStart","Math","min","scrollIntoView","findNext","clearSearchHighlight","exArgs","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","posV","findPosV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","keepHPos","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","to","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","(",")","{","}","[","]","<",">","selfPaired","'","\"","`","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","Number","MAX_VALUE","setSelection","getSelection","replaceSelection","replacement","replaceSelections","getRange","lastState","prevLineEnd","wasLastLine","commands","newlineAndIndent","delete","includeLineBreak","indent","startLine","endLine","indentLine","indentAuto","_args","execCommand","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","getLastEditPos","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","digits","base","0b","0","","0x","number","zeroPadding","from","repeatLastEdit","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","width","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","selection","lines","firstNonWS","search","_forward","noSymbol","wordStart","symbolToMode","*","/","m","M","#","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","ln","curr","last_valid","skip_empty_lines","reverse","curr_index","bracketRegexp","openSym","curChar","scanForBracket","len","chars","firstIndex","SearchState","searchState_","shortText","prompt","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","\\n","\\r","\\t","translateRegexReplace","unescapes","\\/","\\\\","\\&","unescapeRegexReplace","stream","StringStream","output","eol","peek","matcher","parseQuery","lastSearchRegister","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","backUp","skipToEnd","highlightTimeout","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","doc","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","a","anum","bnum","global","matchedLines","content","nextCommand","substitute","trailing","count","replacePart","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","somethingSelected","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","detach","fallthrough","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_g3_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_g3_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default","ie_lt8","navigator","userAgent","documentMode","matching","config","where","getLineHandle","afterCursor","strict","maxScanLen","maxScanLineLength","maxScanLines","stack","lineNo","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","focused","doMatchBrackets","currentlyHighlighted","old","oldConfig","render","_vm","_h","$createElement","_c","_self","staticClass","ref","staticStyle","background-color","margin","attrs","id","cols","rows","staticRenderFns","g3vue_type_script_lang_js_","components","data","CodeMirrorEditor","methods","mounted","log","t","codemirror_default","fromTextArea","$refs","editor","theme","extraKeys","lineNumbers","garbage_g3vue_type_script_lang_js_","component","Object","componentNormalizer","__file","__webpack_exports__","defineMode","cmCfg","modeCfg","htmlMode","getMode","htmlModeMissing","findModeByName","mime","mimes","highlightFormatting","maxBlockquoteDepth","taskLists","strikethrough","emoji","fencedCodeBlockHighlighting","xml","tokenTypeOverrides","tokenTypes","header","code","quote","list1","list2","list3","hr","image","imageAltText","imageMarker","formatting","linkInline","linkEmail","linkText","linkHref","em","strong","tokenType","hrRE","listRE","taskListRE","atxHeaderRE","allowAtxHeaderWithoutSpace","setextHeaderRE","textRE","fencedCodeRE","linkDefRE","punctuation","expandedTab","switchInline","f","inline","switchBlock","lineIsEmpty","string","blankLine","linkTitle","indentedCode","htmlBlock","exit","inner","innerMode","htmlState","tagStart","tokenize","isInText","inlineNormal","blockNormal","trailingSpace","trailingSpaceNewLine","prevLine","thisLine","firstTokenOnLine","indentation","prevLineLineIsEmpty","prevLineIsIndentedCode","prevLineIsHr","prevLineIsList","list","maxNonCodeIndentation","listStack","lineIndentation","indentationDiff","allowsInlineContinuation","fencedCodeEnd","isHr","getType","setext","listType","taskList","fencedEndRE","localMode","localState","lookAhead","footnoteLink","md_inside","returnType","currListInd","hasExitedList","maxFencedEndInd","styles","taskOpen","taskClosed","listMod","handleText","matchCh","regex","previousFormatting","formattingEscape","atts","before","leftFlanking","rightFlanking","setEm","setStrong","retType","getLinkHrefInside","linkRE","endChar","returnState","footnoteLinkInside","footnoteUrl","copyState","textAfter","Pass","blockCommentStart","blockCommentEnd","closeBrackets","fold","defineMIME","doFold","noFold","regexpFlags","flags","multiline","ensureFlags","maybeMultiline","searchRegexpForward","lastIndex","searchRegexpForwardMultiline","chunk","curLine","inside","startCh","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","chunkSize","adjustPos","folded","foldFunc","mid","searchStringForward","caseFold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","normalize","findPrevious","cmpPos","splitLines","defineDocExtension","htmlConfig","autoSelfClosers","area","br","col","embed","frame","img","keygen","link","meta","param","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","p","rp","rt","tbody","td","tfoot","th","tr","contextGrabbers","dt","address","article","aside","blockquote","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","hgroup","menu","nav","ol","pre","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","xmlConfig","allowMissingTagName","editorConf","config_","setStyle","indentUnit","defaults","inText","chain","parser","ok","inBlock","doctype","inTag","baseState","tagName","inAttribute","stringStartCol","closure","isInAttribute","terminator","Context","startOfLine","indented","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","baseIndent","multilineTagIndentPastTag","multilineTagIndentFactor","alignCDATA","tagAfter","grabbers","electricInput","configuration","helperType","skipAttribute","xmlCurrentTag","xmlCurrentContext","cx","mimeModes","modeInfo","ext","file","alias","info","findModeByMIME","findModeByExtension","findModeByFileName","filename","dot"],"mappings":"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","file":"js/chunk-53c0c1cc.91c405aa.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    function updateFatCursorMark(cm) {\n      if (!cm.state.fatCursorMarks) return;\n      clearFatCursorMark(cm);\n      var ranges = cm.listSelections(), result = []\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i]\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\n                                    {className: \"cm-fat-cursor-mark\"}))\n          } else {\n            var widget = document.createElement(\"span\")\n            widget.textContent = \"\\u00a0\"\n            widget.className = \"cm-fat-cursor-mark\"\n            result.push(cm.setBookmark(range.anchor, {widget: widget}))\n          }\n        }\n      }\n      cm.state.fatCursorMarks = result;\n    }\n\n    function clearFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    }\n\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = [];\n      updateFatCursorMark(cm)\n      cm.on(\"cursorActivity\", updateFatCursorMark)\n    }\n\n    function disableFatCursorMark(cm) {\n      clearFatCursorMark(cm);\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n      // explicitly set fatCursorMarks to null because event listener above\n      // can be invoke after removing it, if off is called from operation\n      cm.state.fatCursorMarks = null;\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {type: 'none'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim, keepHPos) {\n        var cur = head;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        if (!keepHPos) {\n          vim.lastHPos = Infinity;\n          vim.lastHSPos = cm.charCoords(end,'div').left;\n        }\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head)\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n","import mod from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./g3.vue?vue&type=style&index=0&lang=scss&\"; export default mod; export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./g3.vue?vue&type=style&index=0&lang=scss&\"","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"g3\"},[_c('div',{staticClass:\"md-editor\"},[_c('textarea',{ref:\"editor\",staticStyle:{\"width\":\"800px\",\"height\":\"400px\",\"background-color\":\"#aaaaaa\",\"margin\":\"0 auto\"},attrs:{\"name\":\"\",\"id\":\"\",\"cols\":\"30\",\"rows\":\"10\"}})])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div class=\"g3\">\n    <div class=\"md-editor\">\n    <textarea ref=\"editor\" name=\"\" id=\"\" cols=\"30\" rows=\"10\"\n              style=\"width: 800px;height: 400px;background-color:#aaaaaa;margin: 0 auto\"> </textarea>\n    </div>\n  </div>\n</template>\n\n<script>\nimport CodeMirror from 'codemirror'\nimport 'codemirror/lib/codemirror.css'\nimport 'codemirror/theme/monokai.css'\nimport 'codemirror/mode/javascript/javascript'\nimport 'codemirror/mode/markdown/markdown'\nimport 'codemirror/keymap/vim.js'\n\nexport default {\n  name: '',\n  components: {},\n  data () {\n    this.CodeMirrorEditor = null\n    return {}\n  },\n  methods: {},\n  mounted () {\n    console.log(window.t = this)\n    console.log(window.cm = CodeMirror)\n\n    this.CodeMirrorEditor = CodeMirror.fromTextArea(this.$refs.editor, {\n      mode: 'markdown',\n      theme: 'monokai',\n      keyMap: 'vim',\n      extraKeys: { 'Ctrl': 'autocomplete' },    // ctrl可以弹出选择项\n      lineNumbers: true\n    })\n  }\n}\n</script>\n\n<style lang=\"scss\">\n  .g3 {\n    .md-editor {\n      width: 300px;\n      .CodeMirror {\n        font-family: Microsoft YaHei monospace;\n        font-size: 13px;\n        line-height: 1.6;\n      }\n\n    }\n  }\n</style>\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./g3.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./g3.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./g3.vue?vue&type=template&id=31a7abb1&\"\nimport script from \"./g3.vue?vue&type=script&lang=js&\"\nexport * from \"./g3.vue?vue&type=script&lang=js&\"\nimport style0 from \"./g3.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"g3.vue\"\nexport default component.exports","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../meta\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../meta\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"markdown\", function(cmCfg, modeCfg) {\n\n  var htmlMode = CodeMirror.getMode(cmCfg, \"text/html\");\n  var htmlModeMissing = htmlMode.name == \"null\"\n\n  function getMode(name) {\n    if (CodeMirror.findModeByName) {\n      var found = CodeMirror.findModeByName(name);\n      if (found) name = found.mime || found.mimes[0];\n    }\n    var mode = CodeMirror.getMode(cmCfg, name);\n    return mode.name == \"null\" ? null : mode;\n  }\n\n  // Should characters that affect highlighting be highlighted separate?\n  // Does not include characters that will be output (such as `1.` and `-` for lists)\n  if (modeCfg.highlightFormatting === undefined)\n    modeCfg.highlightFormatting = false;\n\n  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.\n  // Excess `>` will emit `error` token.\n  if (modeCfg.maxBlockquoteDepth === undefined)\n    modeCfg.maxBlockquoteDepth = 0;\n\n  // Turn on task lists? (\"- [ ] \" and \"- [x] \")\n  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;\n\n  // Turn on strikethrough syntax\n  if (modeCfg.strikethrough === undefined)\n    modeCfg.strikethrough = false;\n\n  if (modeCfg.emoji === undefined)\n    modeCfg.emoji = false;\n\n  if (modeCfg.fencedCodeBlockHighlighting === undefined)\n    modeCfg.fencedCodeBlockHighlighting = true;\n\n  if (modeCfg.xml === undefined)\n    modeCfg.xml = true;\n\n  // Allow token types to be overridden by user-provided token types.\n  if (modeCfg.tokenTypeOverrides === undefined)\n    modeCfg.tokenTypeOverrides = {};\n\n  var tokenTypes = {\n    header: \"header\",\n    code: \"comment\",\n    quote: \"quote\",\n    list1: \"variable-2\",\n    list2: \"variable-3\",\n    list3: \"keyword\",\n    hr: \"hr\",\n    image: \"image\",\n    imageAltText: \"image-alt-text\",\n    imageMarker: \"image-marker\",\n    formatting: \"formatting\",\n    linkInline: \"link\",\n    linkEmail: \"link\",\n    linkText: \"link\",\n    linkHref: \"string\",\n    em: \"em\",\n    strong: \"strong\",\n    strikethrough: \"strikethrough\",\n    emoji: \"builtin\"\n  };\n\n  for (var tokenType in tokenTypes) {\n    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {\n      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];\n    }\n  }\n\n  var hrRE = /^([*\\-_])(?:\\s*\\1){2,}\\s*$/\n  ,   listRE = /^(?:[*\\-+]|^[0-9]+([.)]))\\s+/\n  ,   taskListRE = /^\\[(x| )\\](?=\\s)/i // Must follow listRE\n  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/\n  ,   setextHeaderRE = /^ *(?:\\={1,}|-{1,})\\s*$/\n  ,   textRE = /^[^#!\\[\\]*_\\\\<>` \"'(~:]+/\n  ,   fencedCodeRE = /^(~~~+|```+)[ \\t]*([\\w+#-]*)[^\\n`]*$/\n  ,   linkDefRE = /^\\s*\\[[^\\]]+?\\]:.*$/ // naive link-definition\n  ,   punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/\n  ,   expandedTab = \"    \" // CommonMark specifies tab as 4 spaces\n\n  function switchInline(stream, state, f) {\n    state.f = state.inline = f;\n    return f(stream, state);\n  }\n\n  function switchBlock(stream, state, f) {\n    state.f = state.block = f;\n    return f(stream, state);\n  }\n\n  function lineIsEmpty(line) {\n    return !line || !/\\S/.test(line.string)\n  }\n\n  // Blocks\n\n  function blankLine(state) {\n    // Reset linkTitle state\n    state.linkTitle = false;\n    state.linkHref = false;\n    state.linkText = false;\n    // Reset EM state\n    state.em = false;\n    // Reset STRONG state\n    state.strong = false;\n    // Reset strikethrough state\n    state.strikethrough = false;\n    // Reset state.quote\n    state.quote = 0;\n    // Reset state.indentedCode\n    state.indentedCode = false;\n    if (state.f == htmlBlock) {\n      var exit = htmlModeMissing\n      if (!exit) {\n        var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\n        exit = inner.mode.name == \"xml\" && inner.state.tagStart === null &&\n          (!inner.state.context && inner.state.tokenize.isInText)\n      }\n      if (exit) {\n        state.f = inlineNormal;\n        state.block = blockNormal;\n        state.htmlState = null;\n      }\n    }\n    // Reset state.trailingSpace\n    state.trailingSpace = 0;\n    state.trailingSpaceNewLine = false;\n    // Mark this line as blank\n    state.prevLine = state.thisLine\n    state.thisLine = {stream: null}\n    return null;\n  }\n\n  function blockNormal(stream, state) {\n    var firstTokenOnLine = stream.column() === state.indentation;\n    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);\n    var prevLineIsIndentedCode = state.indentedCode;\n    var prevLineIsHr = state.prevLine.hr;\n    var prevLineIsList = state.list !== false;\n    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;\n\n    state.indentedCode = false;\n\n    var lineIndentation = state.indentation;\n    // compute once per line (on first token)\n    if (state.indentationDiff === null) {\n      state.indentationDiff = state.indentation;\n      if (prevLineIsList) {\n        state.list = null;\n        // While this list item's marker's indentation is less than the deepest\n        //  list item's content's indentation,pop the deepest list item\n        //  indentation off the stack, and update block indentation state\n        while (lineIndentation < state.listStack[state.listStack.length - 1]) {\n          state.listStack.pop();\n          if (state.listStack.length) {\n            state.indentation = state.listStack[state.listStack.length - 1];\n          // less than the first list's indent -> the line is no longer a list\n          } else {\n            state.list = false;\n          }\n        }\n        if (state.list !== false) {\n          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]\n        }\n      }\n    }\n\n    // not comprehensive (currently only for setext detection purposes)\n    var allowsInlineContinuation = (\n        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&\n        (!prevLineIsList || !prevLineIsIndentedCode) &&\n        !state.prevLine.fencedCodeEnd\n    );\n\n    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&\n      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);\n\n    var match = null;\n    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||\n         state.prevLine.header || prevLineLineIsEmpty)) {\n      stream.skipToEnd();\n      state.indentedCode = true;\n      return tokenTypes.code;\n    } else if (stream.eatSpace()) {\n      return null;\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {\n      state.quote = 0;\n      state.header = match[1].length;\n      state.thisLine.header = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      state.f = state.inline;\n      return getType(state);\n    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {\n      state.quote = firstTokenOnLine ? 1 : state.quote + 1;\n      if (modeCfg.highlightFormatting) state.formatting = \"quote\";\n      stream.eatSpace();\n      return getType(state);\n    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {\n      var listType = match[1] ? \"ol\" : \"ul\";\n\n      state.indentation = lineIndentation + stream.current().length;\n      state.list = true;\n      state.quote = 0;\n\n      // Add this list item's content's indentation to the stack\n      state.listStack.push(state.indentation);\n      // Reset inline styles which shouldn't propagate aross list items\n      state.em = false;\n      state.strong = false;\n      state.code = false;\n      state.strikethrough = false;\n\n      if (modeCfg.taskLists && stream.match(taskListRE, false)) {\n        state.taskList = true;\n      }\n      state.f = state.inline;\n      if (modeCfg.highlightFormatting) state.formatting = [\"list\", \"list-\" + listType];\n      return getType(state);\n    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {\n      state.quote = 0;\n      state.fencedEndRE = new RegExp(match[1] + \"+ *$\");\n      // try switching mode\n      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);\n      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);\n      state.f = state.block = local;\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      state.code = -1\n      return getType(state);\n    // SETEXT has lowest block-scope precedence after HR, so check it after\n    //  the others (code, blockquote, list...)\n    } else if (\n      // if setext set, indicates line after ---/===\n      state.setext || (\n        // line before ---/===\n        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&\n        !state.code && !isHr && !linkDefRE.test(stream.string) &&\n        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))\n      )\n    ) {\n      if ( !state.setext ) {\n        state.header = match[0].charAt(0) == '=' ? 1 : 2;\n        state.setext = state.header;\n      } else {\n        state.header = state.setext;\n        // has no effect on type so we can reset it now\n        state.setext = 0;\n        stream.skipToEnd();\n        if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      }\n      state.thisLine.header = true;\n      state.f = state.inline;\n      return getType(state);\n    } else if (isHr) {\n      stream.skipToEnd();\n      state.hr = true;\n      state.thisLine.hr = true;\n      return tokenTypes.hr;\n    } else if (stream.peek() === '[') {\n      return switchInline(stream, state, footnoteLink);\n    }\n\n    return switchInline(stream, state, state.inline);\n  }\n\n  function htmlBlock(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if (!htmlModeMissing) {\n      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)\n      if ((inner.mode.name == \"xml\" && inner.state.tagStart === null &&\n           (!inner.state.context && inner.state.tokenize.isInText)) ||\n          (state.md_inside && stream.current().indexOf(\">\") > -1)) {\n        state.f = inlineNormal;\n        state.block = blockNormal;\n        state.htmlState = null;\n      }\n    }\n    return style;\n  }\n\n  function local(stream, state) {\n    var currListInd = state.listStack[state.listStack.length - 1] || 0;\n    var hasExitedList = state.indentation < currListInd;\n    var maxFencedEndInd = currListInd + 3;\n    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {\n      if (modeCfg.highlightFormatting) state.formatting = \"code-block\";\n      var returnType;\n      if (!hasExitedList) returnType = getType(state)\n      state.localMode = state.localState = null;\n      state.block = blockNormal;\n      state.f = inlineNormal;\n      state.fencedEndRE = null;\n      state.code = 0\n      state.thisLine.fencedCodeEnd = true;\n      if (hasExitedList) return switchBlock(stream, state, state.block);\n      return returnType;\n    } else if (state.localMode) {\n      return state.localMode.token(stream, state.localState);\n    } else {\n      stream.skipToEnd();\n      return tokenTypes.code;\n    }\n  }\n\n  // Inline\n  function getType(state) {\n    var styles = [];\n\n    if (state.formatting) {\n      styles.push(tokenTypes.formatting);\n\n      if (typeof state.formatting === \"string\") state.formatting = [state.formatting];\n\n      for (var i = 0; i < state.formatting.length; i++) {\n        styles.push(tokenTypes.formatting + \"-\" + state.formatting[i]);\n\n        if (state.formatting[i] === \"header\") {\n          styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.header);\n        }\n\n        // Add `formatting-quote` and `formatting-quote-#` for blockquotes\n        // Add `error` instead if the maximum blockquote nesting depth is passed\n        if (state.formatting[i] === \"quote\") {\n          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n            styles.push(tokenTypes.formatting + \"-\" + state.formatting[i] + \"-\" + state.quote);\n          } else {\n            styles.push(\"error\");\n          }\n        }\n      }\n    }\n\n    if (state.taskOpen) {\n      styles.push(\"meta\");\n      return styles.length ? styles.join(' ') : null;\n    }\n    if (state.taskClosed) {\n      styles.push(\"property\");\n      return styles.length ? styles.join(' ') : null;\n    }\n\n    if (state.linkHref) {\n      styles.push(tokenTypes.linkHref, \"url\");\n    } else { // Only apply inline styles to non-url text\n      if (state.strong) { styles.push(tokenTypes.strong); }\n      if (state.em) { styles.push(tokenTypes.em); }\n      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }\n      if (state.emoji) { styles.push(tokenTypes.emoji); }\n      if (state.linkText) { styles.push(tokenTypes.linkText); }\n      if (state.code) { styles.push(tokenTypes.code); }\n      if (state.image) { styles.push(tokenTypes.image); }\n      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, \"link\"); }\n      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }\n    }\n\n    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + \"-\" + state.header); }\n\n    if (state.quote) {\n      styles.push(tokenTypes.quote);\n\n      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth\n      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {\n        styles.push(tokenTypes.quote + \"-\" + state.quote);\n      } else {\n        styles.push(tokenTypes.quote + \"-\" + modeCfg.maxBlockquoteDepth);\n      }\n    }\n\n    if (state.list !== false) {\n      var listMod = (state.listStack.length - 1) % 3;\n      if (!listMod) {\n        styles.push(tokenTypes.list1);\n      } else if (listMod === 1) {\n        styles.push(tokenTypes.list2);\n      } else {\n        styles.push(tokenTypes.list3);\n      }\n    }\n\n    if (state.trailingSpaceNewLine) {\n      styles.push(\"trailing-space-new-line\");\n    } else if (state.trailingSpace) {\n      styles.push(\"trailing-space-\" + (state.trailingSpace % 2 ? \"a\" : \"b\"));\n    }\n\n    return styles.length ? styles.join(' ') : null;\n  }\n\n  function handleText(stream, state) {\n    if (stream.match(textRE, true)) {\n      return getType(state);\n    }\n    return undefined;\n  }\n\n  function inlineNormal(stream, state) {\n    var style = state.text(stream, state);\n    if (typeof style !== 'undefined')\n      return style;\n\n    if (state.list) { // List marker (*, +, -, 1., etc)\n      state.list = null;\n      return getType(state);\n    }\n\n    if (state.taskList) {\n      var taskOpen = stream.match(taskListRE, true)[1] === \" \";\n      if (taskOpen) state.taskOpen = true;\n      else state.taskClosed = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"task\";\n      state.taskList = false;\n      return getType(state);\n    }\n\n    state.taskOpen = false;\n    state.taskClosed = false;\n\n    if (state.header && stream.match(/^#+$/, true)) {\n      if (modeCfg.highlightFormatting) state.formatting = \"header\";\n      return getType(state);\n    }\n\n    var ch = stream.next();\n\n    // Matches link titles present on next line\n    if (state.linkTitle) {\n      state.linkTitle = false;\n      var matchCh = ch;\n      if (ch === '(') {\n        matchCh = ')';\n      }\n      matchCh = (matchCh+'').replace(/([.?*+^\\[\\]\\\\(){}|-])/g, \"\\\\$1\");\n      var regex = '^\\\\s*(?:[^' + matchCh + '\\\\\\\\]+|\\\\\\\\\\\\\\\\|\\\\\\\\.)' + matchCh;\n      if (stream.match(new RegExp(regex), true)) {\n        return tokenTypes.linkHref;\n      }\n    }\n\n    // If this block is changed, it may need to be updated in GFM mode\n    if (ch === '`') {\n      var previousFormatting = state.formatting;\n      if (modeCfg.highlightFormatting) state.formatting = \"code\";\n      stream.eatWhile('`');\n      var count = stream.current().length\n      if (state.code == 0 && (!state.quote || count == 1)) {\n        state.code = count\n        return getType(state)\n      } else if (count == state.code) { // Must be exact\n        var t = getType(state)\n        state.code = 0\n        return t\n      } else {\n        state.formatting = previousFormatting\n        return getType(state)\n      }\n    } else if (state.code) {\n      return getType(state);\n    }\n\n    if (ch === '\\\\') {\n      stream.next();\n      if (modeCfg.highlightFormatting) {\n        var type = getType(state);\n        var formattingEscape = tokenTypes.formatting + \"-escape\";\n        return type ? type + \" \" + formattingEscape : formattingEscape;\n      }\n    }\n\n    if (ch === '!' && stream.match(/\\[[^\\]]*\\] ?(?:\\(|\\[)/, false)) {\n      state.imageMarker = true;\n      state.image = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      return getType(state);\n    }\n\n    if (ch === '[' && state.imageMarker && stream.match(/[^\\]]*\\](\\(.*?\\)| ?\\[.*?\\])/, false)) {\n      state.imageMarker = false;\n      state.imageAltText = true\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.imageAltText) {\n      if (modeCfg.highlightFormatting) state.formatting = \"image\";\n      var type = getType(state);\n      state.imageAltText = false;\n      state.image = false;\n      state.inline = state.f = linkHref;\n      return type;\n    }\n\n    if (ch === '[' && !state.image) {\n      if (state.linkText && stream.match(/^.*?\\]/)) return getType(state)\n      state.linkText = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      return getType(state);\n    }\n\n    if (ch === ']' && state.linkText) {\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      state.linkText = false;\n      state.inline = state.f = stream.match(/\\(.*?\\)| ?\\[.*?\\]/, false) ? linkHref : inlineNormal\n      return type;\n    }\n\n    if (ch === '<' && stream.match(/^(https?|ftps?):\\/\\/(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    if (ch === '<' && stream.match(/^[^> \\\\]+@(?:[^\\\\>]|\\\\.)+>/, false)) {\n      state.f = state.inline = linkInline;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkEmail;\n    }\n\n    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|\\?|!\\[CDATA\\[|[a-z][a-z0-9-]*(?:\\s+[a-z_:.\\-]+(?:\\s*=\\s*[^>]+)?)*\\s*(?:>|$))/i, false)) {\n      var end = stream.string.indexOf(\">\", stream.pos);\n      if (end != -1) {\n        var atts = stream.string.substring(stream.start, end);\n        if (/markdown\\s*=\\s*('|\"){0,1}1('|\"){0,1}/.test(atts)) state.md_inside = true;\n      }\n      stream.backUp(1);\n      state.htmlState = CodeMirror.startState(htmlMode);\n      return switchBlock(stream, state, htmlBlock);\n    }\n\n    if (modeCfg.xml && ch === '<' && stream.match(/^\\/\\w*?>/)) {\n      state.md_inside = false;\n      return \"tag\";\n    } else if (ch === \"*\" || ch === \"_\") {\n      var len = 1, before = stream.pos == 1 ? \" \" : stream.string.charAt(stream.pos - 2)\n      while (len < 3 && stream.eat(ch)) len++\n      var after = stream.peek() || \" \"\n      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis\n      var leftFlanking = !/\\s/.test(after) && (!punctuation.test(after) || /\\s/.test(before) || punctuation.test(before))\n      var rightFlanking = !/\\s/.test(before) && (!punctuation.test(before) || /\\s/.test(after) || punctuation.test(after))\n      var setEm = null, setStrong = null\n      if (len % 2) { // Em\n        if (!state.em && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\n          setEm = true\n        else if (state.em == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\n          setEm = false\n      }\n      if (len > 1) { // Strong\n        if (!state.strong && leftFlanking && (ch === \"*\" || !rightFlanking || punctuation.test(before)))\n          setStrong = true\n        else if (state.strong == ch && rightFlanking && (ch === \"*\" || !leftFlanking || punctuation.test(after)))\n          setStrong = false\n      }\n      if (setStrong != null || setEm != null) {\n        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? \"strong\" : setStrong == null ? \"em\" : \"strong em\"\n        if (setEm === true) state.em = ch\n        if (setStrong === true) state.strong = ch\n        var t = getType(state)\n        if (setEm === false) state.em = false\n        if (setStrong === false) state.strong = false\n        return t\n      }\n    } else if (ch === ' ') {\n      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces\n        if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n          return getType(state);\n        } else { // Not surrounded by spaces, back up pointer\n          stream.backUp(1);\n        }\n      }\n    }\n\n    if (modeCfg.strikethrough) {\n      if (ch === '~' && stream.eatWhile(ch)) {\n        if (state.strikethrough) {// Remove strikethrough\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          var t = getType(state);\n          state.strikethrough = false;\n          return t;\n        } else if (stream.match(/^[^\\s]/, false)) {// Add strikethrough\n          state.strikethrough = true;\n          if (modeCfg.highlightFormatting) state.formatting = \"strikethrough\";\n          return getType(state);\n        }\n      } else if (ch === ' ') {\n        if (stream.match(/^~~/, true)) { // Probably surrounded by space\n          if (stream.peek() === ' ') { // Surrounded by spaces, ignore\n            return getType(state);\n          } else { // Not surrounded by spaces, back up pointer\n            stream.backUp(2);\n          }\n        }\n      }\n    }\n\n    if (modeCfg.emoji && ch === \":\" && stream.match(/^(?:[a-z_\\d+][a-z_\\d+-]*|\\-[a-z_\\d+][a-z_\\d+-]*):/)) {\n      state.emoji = true;\n      if (modeCfg.highlightFormatting) state.formatting = \"emoji\";\n      var retType = getType(state);\n      state.emoji = false;\n      return retType;\n    }\n\n    if (ch === ' ') {\n      if (stream.match(/^ +$/, false)) {\n        state.trailingSpace++;\n      } else if (state.trailingSpace) {\n        state.trailingSpaceNewLine = true;\n      }\n    }\n\n    return getType(state);\n  }\n\n  function linkInline(stream, state) {\n    var ch = stream.next();\n\n    if (ch === \">\") {\n      state.f = state.inline = inlineNormal;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var type = getType(state);\n      if (type){\n        type += \" \";\n      } else {\n        type = \"\";\n      }\n      return type + tokenTypes.linkInline;\n    }\n\n    stream.match(/^[^>]+/, true);\n\n    return tokenTypes.linkInline;\n  }\n\n  function linkHref(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    var ch = stream.next();\n    if (ch === '(' || ch === '[') {\n      state.f = state.inline = getLinkHrefInside(ch === \"(\" ? \")\" : \"]\");\n      if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n      state.linkHref = true;\n      return getType(state);\n    }\n    return 'error';\n  }\n\n  var linkRE = {\n    \")\": /^(?:[^\\\\\\(\\)]|\\\\.|\\((?:[^\\\\\\(\\)]|\\\\.)*\\))*?(?=\\))/,\n    \"]\": /^(?:[^\\\\\\[\\]]|\\\\.|\\[(?:[^\\\\\\[\\]]|\\\\.)*\\])*?(?=\\])/\n  }\n\n  function getLinkHrefInside(endChar) {\n    return function(stream, state) {\n      var ch = stream.next();\n\n      if (ch === endChar) {\n        state.f = state.inline = inlineNormal;\n        if (modeCfg.highlightFormatting) state.formatting = \"link-string\";\n        var returnState = getType(state);\n        state.linkHref = false;\n        return returnState;\n      }\n\n      stream.match(linkRE[endChar])\n      state.linkHref = true;\n      return getType(state);\n    };\n  }\n\n  function footnoteLink(stream, state) {\n    if (stream.match(/^([^\\]\\\\]|\\\\.)*\\]:/, false)) {\n      state.f = footnoteLinkInside;\n      stream.next(); // Consume [\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      state.linkText = true;\n      return getType(state);\n    }\n    return switchInline(stream, state, inlineNormal);\n  }\n\n  function footnoteLinkInside(stream, state) {\n    if (stream.match(/^\\]:/, true)) {\n      state.f = state.inline = footnoteUrl;\n      if (modeCfg.highlightFormatting) state.formatting = \"link\";\n      var returnType = getType(state);\n      state.linkText = false;\n      return returnType;\n    }\n\n    stream.match(/^([^\\]\\\\]|\\\\.)+/, true);\n\n    return tokenTypes.linkText;\n  }\n\n  function footnoteUrl(stream, state) {\n    // Check if space, and return NULL if so (to avoid marking the space)\n    if(stream.eatSpace()){\n      return null;\n    }\n    // Match URL\n    stream.match(/^[^\\s]+/, true);\n    // Check for link title\n    if (stream.peek() === undefined) { // End of line, set flag to check next line\n      state.linkTitle = true;\n    } else { // More content on line, check if link title\n      stream.match(/^(?:\\s+(?:\"(?:[^\"\\\\]|\\\\\\\\|\\\\.)+\"|'(?:[^'\\\\]|\\\\\\\\|\\\\.)+'|\\((?:[^)\\\\]|\\\\\\\\|\\\\.)+\\)))?/, true);\n    }\n    state.f = state.inline = inlineNormal;\n    return tokenTypes.linkHref + \" url\";\n  }\n\n  var mode = {\n    startState: function() {\n      return {\n        f: blockNormal,\n\n        prevLine: {stream: null},\n        thisLine: {stream: null},\n\n        block: blockNormal,\n        htmlState: null,\n        indentation: 0,\n\n        inline: inlineNormal,\n        text: handleText,\n\n        formatting: false,\n        linkText: false,\n        linkHref: false,\n        linkTitle: false,\n        code: 0,\n        em: false,\n        strong: false,\n        header: 0,\n        setext: 0,\n        hr: false,\n        taskList: false,\n        list: false,\n        listStack: [],\n        quote: 0,\n        trailingSpace: 0,\n        trailingSpaceNewLine: false,\n        strikethrough: false,\n        emoji: false,\n        fencedEndRE: null\n      };\n    },\n\n    copyState: function(s) {\n      return {\n        f: s.f,\n\n        prevLine: s.prevLine,\n        thisLine: s.thisLine,\n\n        block: s.block,\n        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),\n        indentation: s.indentation,\n\n        localMode: s.localMode,\n        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,\n\n        inline: s.inline,\n        text: s.text,\n        formatting: false,\n        linkText: s.linkText,\n        linkTitle: s.linkTitle,\n        linkHref: s.linkHref,\n        code: s.code,\n        em: s.em,\n        strong: s.strong,\n        strikethrough: s.strikethrough,\n        emoji: s.emoji,\n        header: s.header,\n        setext: s.setext,\n        hr: s.hr,\n        taskList: s.taskList,\n        list: s.list,\n        listStack: s.listStack.slice(0),\n        quote: s.quote,\n        indentedCode: s.indentedCode,\n        trailingSpace: s.trailingSpace,\n        trailingSpaceNewLine: s.trailingSpaceNewLine,\n        md_inside: s.md_inside,\n        fencedEndRE: s.fencedEndRE\n      };\n    },\n\n    token: function(stream, state) {\n\n      // Reset state.formatting\n      state.formatting = false;\n\n      if (stream != state.thisLine.stream) {\n        state.header = 0;\n        state.hr = false;\n\n        if (stream.match(/^\\s*$/, true)) {\n          blankLine(state);\n          return null;\n        }\n\n        state.prevLine = state.thisLine\n        state.thisLine = {stream: stream}\n\n        // Reset state.taskList\n        state.taskList = false;\n\n        // Reset state.trailingSpace\n        state.trailingSpace = 0;\n        state.trailingSpaceNewLine = false;\n\n        if (!state.localState) {\n          state.f = state.block;\n          if (state.f != htmlBlock) {\n            var indentation = stream.match(/^\\s*/, true)[0].replace(/\\t/g, expandedTab).length;\n            state.indentation = indentation;\n            state.indentationDiff = null;\n            if (indentation > 0) return null;\n          }\n        }\n      }\n      return state.f(stream, state);\n    },\n\n    innerMode: function(state) {\n      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};\n      if (state.localState) return {state: state.localState, mode: state.localMode};\n      return {state: state, mode: mode};\n    },\n\n    indent: function(state, textAfter, line) {\n      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)\n      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)\n      return CodeMirror.Pass\n    },\n\n    blankLine: blankLine,\n\n    getType: getType,\n\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n    fold: \"markdown\"\n  };\n  return mode;\n}, \"xml\");\n\nCodeMirror.defineMIME(\"text/markdown\", \"markdown\");\n\nCodeMirror.defineMIME(\"text/x-markdown\", \"markdown\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        if (cx.tagName) context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.modeInfo = [\n    {name: \"APL\", mime: \"text/apl\", mode: \"apl\", ext: [\"dyalog\", \"apl\"]},\n    {name: \"PGP\", mimes: [\"application/pgp\", \"application/pgp-encrypted\", \"application/pgp-keys\", \"application/pgp-signature\"], mode: \"asciiarmor\", ext: [\"asc\", \"pgp\", \"sig\"]},\n    {name: \"ASN.1\", mime: \"text/x-ttcn-asn\", mode: \"asn.1\", ext: [\"asn\", \"asn1\"]},\n    {name: \"Asterisk\", mime: \"text/x-asterisk\", mode: \"asterisk\", file: /^extensions\\.conf$/i},\n    {name: \"Brainfuck\", mime: \"text/x-brainfuck\", mode: \"brainfuck\", ext: [\"b\", \"bf\"]},\n    {name: \"C\", mime: \"text/x-csrc\", mode: \"clike\", ext: [\"c\", \"h\", \"ino\"]},\n    {name: \"C++\", mime: \"text/x-c++src\", mode: \"clike\", ext: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"], alias: [\"cpp\"]},\n    {name: \"Cobol\", mime: \"text/x-cobol\", mode: \"cobol\", ext: [\"cob\", \"cpy\"]},\n    {name: \"C#\", mime: \"text/x-csharp\", mode: \"clike\", ext: [\"cs\"], alias: [\"csharp\", \"cs\"]},\n    {name: \"Clojure\", mime: \"text/x-clojure\", mode: \"clojure\", ext: [\"clj\", \"cljc\", \"cljx\"]},\n    {name: \"ClojureScript\", mime: \"text/x-clojurescript\", mode: \"clojure\", ext: [\"cljs\"]},\n    {name: \"Closure Stylesheets (GSS)\", mime: \"text/x-gss\", mode: \"css\", ext: [\"gss\"]},\n    {name: \"CMake\", mime: \"text/x-cmake\", mode: \"cmake\", ext: [\"cmake\", \"cmake.in\"], file: /^CMakeLists.txt$/},\n    {name: \"CoffeeScript\", mimes: [\"application/vnd.coffeescript\", \"text/coffeescript\", \"text/x-coffeescript\"], mode: \"coffeescript\", ext: [\"coffee\"], alias: [\"coffee\", \"coffee-script\"]},\n    {name: \"Common Lisp\", mime: \"text/x-common-lisp\", mode: \"commonlisp\", ext: [\"cl\", \"lisp\", \"el\"], alias: [\"lisp\"]},\n    {name: \"Cypher\", mime: \"application/x-cypher-query\", mode: \"cypher\", ext: [\"cyp\", \"cypher\"]},\n    {name: \"Cython\", mime: \"text/x-cython\", mode: \"python\", ext: [\"pyx\", \"pxd\", \"pxi\"]},\n    {name: \"Crystal\", mime: \"text/x-crystal\", mode: \"crystal\", ext: [\"cr\"]},\n    {name: \"CSS\", mime: \"text/css\", mode: \"css\", ext: [\"css\"]},\n    {name: \"CQL\", mime: \"text/x-cassandra\", mode: \"sql\", ext: [\"cql\"]},\n    {name: \"D\", mime: \"text/x-d\", mode: \"d\", ext: [\"d\"]},\n    {name: \"Dart\", mimes: [\"application/dart\", \"text/x-dart\"], mode: \"dart\", ext: [\"dart\"]},\n    {name: \"diff\", mime: \"text/x-diff\", mode: \"diff\", ext: [\"diff\", \"patch\"]},\n    {name: \"Django\", mime: \"text/x-django\", mode: \"django\"},\n    {name: \"Dockerfile\", mime: \"text/x-dockerfile\", mode: \"dockerfile\", file: /^Dockerfile$/},\n    {name: \"DTD\", mime: \"application/xml-dtd\", mode: \"dtd\", ext: [\"dtd\"]},\n    {name: \"Dylan\", mime: \"text/x-dylan\", mode: \"dylan\", ext: [\"dylan\", \"dyl\", \"intr\"]},\n    {name: \"EBNF\", mime: \"text/x-ebnf\", mode: \"ebnf\"},\n    {name: \"ECL\", mime: \"text/x-ecl\", mode: \"ecl\", ext: [\"ecl\"]},\n    {name: \"edn\", mime: \"application/edn\", mode: \"clojure\", ext: [\"edn\"]},\n    {name: \"Eiffel\", mime: \"text/x-eiffel\", mode: \"eiffel\", ext: [\"e\"]},\n    {name: \"Elm\", mime: \"text/x-elm\", mode: \"elm\", ext: [\"elm\"]},\n    {name: \"Embedded Javascript\", mime: \"application/x-ejs\", mode: \"htmlembedded\", ext: [\"ejs\"]},\n    {name: \"Embedded Ruby\", mime: \"application/x-erb\", mode: \"htmlembedded\", ext: [\"erb\"]},\n    {name: \"Erlang\", mime: \"text/x-erlang\", mode: \"erlang\", ext: [\"erl\"]},\n    {name: \"Esper\", mime: \"text/x-esper\", mode: \"sql\"},\n    {name: \"Factor\", mime: \"text/x-factor\", mode: \"factor\", ext: [\"factor\"]},\n    {name: \"FCL\", mime: \"text/x-fcl\", mode: \"fcl\"},\n    {name: \"Forth\", mime: \"text/x-forth\", mode: \"forth\", ext: [\"forth\", \"fth\", \"4th\"]},\n    {name: \"Fortran\", mime: \"text/x-fortran\", mode: \"fortran\", ext: [\"f\", \"for\", \"f77\", \"f90\", \"f95\"]},\n    {name: \"F#\", mime: \"text/x-fsharp\", mode: \"mllike\", ext: [\"fs\"], alias: [\"fsharp\"]},\n    {name: \"Gas\", mime: \"text/x-gas\", mode: \"gas\", ext: [\"s\"]},\n    {name: \"Gherkin\", mime: \"text/x-feature\", mode: \"gherkin\", ext: [\"feature\"]},\n    {name: \"GitHub Flavored Markdown\", mime: \"text/x-gfm\", mode: \"gfm\", file: /^(readme|contributing|history).md$/i},\n    {name: \"Go\", mime: \"text/x-go\", mode: \"go\", ext: [\"go\"]},\n    {name: \"Groovy\", mime: \"text/x-groovy\", mode: \"groovy\", ext: [\"groovy\", \"gradle\"], file: /^Jenkinsfile$/},\n    {name: \"HAML\", mime: \"text/x-haml\", mode: \"haml\", ext: [\"haml\"]},\n    {name: \"Haskell\", mime: \"text/x-haskell\", mode: \"haskell\", ext: [\"hs\"]},\n    {name: \"Haskell (Literate)\", mime: \"text/x-literate-haskell\", mode: \"haskell-literate\", ext: [\"lhs\"]},\n    {name: \"Haxe\", mime: \"text/x-haxe\", mode: \"haxe\", ext: [\"hx\"]},\n    {name: \"HXML\", mime: \"text/x-hxml\", mode: \"haxe\", ext: [\"hxml\"]},\n    {name: \"ASP.NET\", mime: \"application/x-aspx\", mode: \"htmlembedded\", ext: [\"aspx\"], alias: [\"asp\", \"aspx\"]},\n    {name: \"HTML\", mime: \"text/html\", mode: \"htmlmixed\", ext: [\"html\", \"htm\", \"handlebars\", \"hbs\"], alias: [\"xhtml\"]},\n    {name: \"HTTP\", mime: \"message/http\", mode: \"http\"},\n    {name: \"IDL\", mime: \"text/x-idl\", mode: \"idl\", ext: [\"pro\"]},\n    {name: \"Pug\", mime: \"text/x-pug\", mode: \"pug\", ext: [\"jade\", \"pug\"], alias: [\"jade\"]},\n    {name: \"Java\", mime: \"text/x-java\", mode: \"clike\", ext: [\"java\"]},\n    {name: \"Java Server Pages\", mime: \"application/x-jsp\", mode: \"htmlembedded\", ext: [\"jsp\"], alias: [\"jsp\"]},\n    {name: \"JavaScript\", mimes: [\"text/javascript\", \"text/ecmascript\", \"application/javascript\", \"application/x-javascript\", \"application/ecmascript\"],\n     mode: \"javascript\", ext: [\"js\"], alias: [\"ecmascript\", \"js\", \"node\"]},\n    {name: \"JSON\", mimes: [\"application/json\", \"application/x-json\"], mode: \"javascript\", ext: [\"json\", \"map\"], alias: [\"json5\"]},\n    {name: \"JSON-LD\", mime: \"application/ld+json\", mode: \"javascript\", ext: [\"jsonld\"], alias: [\"jsonld\"]},\n    {name: \"JSX\", mime: \"text/jsx\", mode: \"jsx\", ext: [\"jsx\"]},\n    {name: \"Jinja2\", mime: \"text/jinja2\", mode: \"jinja2\", ext: [\"j2\", \"jinja\", \"jinja2\"]},\n    {name: \"Julia\", mime: \"text/x-julia\", mode: \"julia\", ext: [\"jl\"]},\n    {name: \"Kotlin\", mime: \"text/x-kotlin\", mode: \"clike\", ext: [\"kt\"]},\n    {name: \"LESS\", mime: \"text/x-less\", mode: \"css\", ext: [\"less\"]},\n    {name: \"LiveScript\", mime: \"text/x-livescript\", mode: \"livescript\", ext: [\"ls\"], alias: [\"ls\"]},\n    {name: \"Lua\", mime: \"text/x-lua\", mode: \"lua\", ext: [\"lua\"]},\n    {name: \"Markdown\", mime: \"text/x-markdown\", mode: \"markdown\", ext: [\"markdown\", \"md\", \"mkd\"]},\n    {name: \"mIRC\", mime: \"text/mirc\", mode: \"mirc\"},\n    {name: \"MariaDB SQL\", mime: \"text/x-mariadb\", mode: \"sql\"},\n    {name: \"Mathematica\", mime: \"text/x-mathematica\", mode: \"mathematica\", ext: [\"m\", \"nb\", \"wl\", \"wls\"]},\n    {name: \"Modelica\", mime: \"text/x-modelica\", mode: \"modelica\", ext: [\"mo\"]},\n    {name: \"MUMPS\", mime: \"text/x-mumps\", mode: \"mumps\", ext: [\"mps\"]},\n    {name: \"MS SQL\", mime: \"text/x-mssql\", mode: \"sql\"},\n    {name: \"mbox\", mime: \"application/mbox\", mode: \"mbox\", ext: [\"mbox\"]},\n    {name: \"MySQL\", mime: \"text/x-mysql\", mode: \"sql\"},\n    {name: \"Nginx\", mime: \"text/x-nginx-conf\", mode: \"nginx\", file: /nginx.*\\.conf$/i},\n    {name: \"NSIS\", mime: \"text/x-nsis\", mode: \"nsis\", ext: [\"nsh\", \"nsi\"]},\n    {name: \"NTriples\", mimes: [\"application/n-triples\", \"application/n-quads\", \"text/n-triples\"],\n     mode: \"ntriples\", ext: [\"nt\", \"nq\"]},\n    {name: \"Objective-C\", mime: \"text/x-objectivec\", mode: \"clike\", ext: [\"m\"], alias: [\"objective-c\", \"objc\"]},\n    {name: \"Objective-C++\", mime: \"text/x-objectivec++\", mode: \"clike\", ext: [\"mm\"], alias: [\"objective-c++\", \"objc++\"]},\n    {name: \"OCaml\", mime: \"text/x-ocaml\", mode: \"mllike\", ext: [\"ml\", \"mli\", \"mll\", \"mly\"]},\n    {name: \"Octave\", mime: \"text/x-octave\", mode: \"octave\", ext: [\"m\"]},\n    {name: \"Oz\", mime: \"text/x-oz\", mode: \"oz\", ext: [\"oz\"]},\n    {name: \"Pascal\", mime: \"text/x-pascal\", mode: \"pascal\", ext: [\"p\", \"pas\"]},\n    {name: \"PEG.js\", mime: \"null\", mode: \"pegjs\", ext: [\"jsonld\"]},\n    {name: \"Perl\", mime: \"text/x-perl\", mode: \"perl\", ext: [\"pl\", \"pm\"]},\n    {name: \"PHP\", mimes: [\"text/x-php\", \"application/x-httpd-php\", \"application/x-httpd-php-open\"], mode: \"php\", ext: [\"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"phtml\"]},\n    {name: \"Pig\", mime: \"text/x-pig\", mode: \"pig\", ext: [\"pig\"]},\n    {name: \"Plain Text\", mime: \"text/plain\", mode: \"null\", ext: [\"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\"]},\n    {name: \"PLSQL\", mime: \"text/x-plsql\", mode: \"sql\", ext: [\"pls\"]},\n    {name: \"PostgreSQL\", mime: \"text/x-pgsql\", mode: \"sql\"},\n    {name: \"PowerShell\", mime: \"application/x-powershell\", mode: \"powershell\", ext: [\"ps1\", \"psd1\", \"psm1\"]},\n    {name: \"Properties files\", mime: \"text/x-properties\", mode: \"properties\", ext: [\"properties\", \"ini\", \"in\"], alias: [\"ini\", \"properties\"]},\n    {name: \"ProtoBuf\", mime: \"text/x-protobuf\", mode: \"protobuf\", ext: [\"proto\"]},\n    {name: \"Python\", mime: \"text/x-python\", mode: \"python\", ext: [\"BUILD\", \"bzl\", \"py\", \"pyw\"], file: /^(BUCK|BUILD)$/},\n    {name: \"Puppet\", mime: \"text/x-puppet\", mode: \"puppet\", ext: [\"pp\"]},\n    {name: \"Q\", mime: \"text/x-q\", mode: \"q\", ext: [\"q\"]},\n    {name: \"R\", mime: \"text/x-rsrc\", mode: \"r\", ext: [\"r\", \"R\"], alias: [\"rscript\"]},\n    {name: \"reStructuredText\", mime: \"text/x-rst\", mode: \"rst\", ext: [\"rst\"], alias: [\"rst\"]},\n    {name: \"RPM Changes\", mime: \"text/x-rpm-changes\", mode: \"rpm\"},\n    {name: \"RPM Spec\", mime: \"text/x-rpm-spec\", mode: \"rpm\", ext: [\"spec\"]},\n    {name: \"Ruby\", mime: \"text/x-ruby\", mode: \"ruby\", ext: [\"rb\"], alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"]},\n    {name: \"Rust\", mime: \"text/x-rustsrc\", mode: \"rust\", ext: [\"rs\"]},\n    {name: \"SAS\", mime: \"text/x-sas\", mode: \"sas\", ext: [\"sas\"]},\n    {name: \"Sass\", mime: \"text/x-sass\", mode: \"sass\", ext: [\"sass\"]},\n    {name: \"Scala\", mime: \"text/x-scala\", mode: \"clike\", ext: [\"scala\"]},\n    {name: \"Scheme\", mime: \"text/x-scheme\", mode: \"scheme\", ext: [\"scm\", \"ss\"]},\n    {name: \"SCSS\", mime: \"text/x-scss\", mode: \"css\", ext: [\"scss\"]},\n    {name: \"Shell\", mimes: [\"text/x-sh\", \"application/x-sh\"], mode: \"shell\", ext: [\"sh\", \"ksh\", \"bash\"], alias: [\"bash\", \"sh\", \"zsh\"], file: /^PKGBUILD$/},\n    {name: \"Sieve\", mime: \"application/sieve\", mode: \"sieve\", ext: [\"siv\", \"sieve\"]},\n    {name: \"Slim\", mimes: [\"text/x-slim\", \"application/x-slim\"], mode: \"slim\", ext: [\"slim\"]},\n    {name: \"Smalltalk\", mime: \"text/x-stsrc\", mode: \"smalltalk\", ext: [\"st\"]},\n    {name: \"Smarty\", mime: \"text/x-smarty\", mode: \"smarty\", ext: [\"tpl\"]},\n    {name: \"Solr\", mime: \"text/x-solr\", mode: \"solr\"},\n    {name: \"SML\", mime: \"text/x-sml\", mode: \"mllike\", ext: [\"sml\", \"sig\", \"fun\", \"smackspec\"]},\n    {name: \"Soy\", mime: \"text/x-soy\", mode: \"soy\", ext: [\"soy\"], alias: [\"closure template\"]},\n    {name: \"SPARQL\", mime: \"application/sparql-query\", mode: \"sparql\", ext: [\"rq\", \"sparql\"], alias: [\"sparul\"]},\n    {name: \"Spreadsheet\", mime: \"text/x-spreadsheet\", mode: \"spreadsheet\", alias: [\"excel\", \"formula\"]},\n    {name: \"SQL\", mime: \"text/x-sql\", mode: \"sql\", ext: [\"sql\"]},\n    {name: \"SQLite\", mime: \"text/x-sqlite\", mode: \"sql\"},\n    {name: \"Squirrel\", mime: \"text/x-squirrel\", mode: \"clike\", ext: [\"nut\"]},\n    {name: \"Stylus\", mime: \"text/x-styl\", mode: \"stylus\", ext: [\"styl\"]},\n    {name: \"Swift\", mime: \"text/x-swift\", mode: \"swift\", ext: [\"swift\"]},\n    {name: \"sTeX\", mime: \"text/x-stex\", mode: \"stex\"},\n    {name: \"LaTeX\", mime: \"text/x-latex\", mode: \"stex\", ext: [\"text\", \"ltx\", \"tex\"], alias: [\"tex\"]},\n    {name: \"SystemVerilog\", mime: \"text/x-systemverilog\", mode: \"verilog\", ext: [\"v\", \"sv\", \"svh\"]},\n    {name: \"Tcl\", mime: \"text/x-tcl\", mode: \"tcl\", ext: [\"tcl\"]},\n    {name: \"Textile\", mime: \"text/x-textile\", mode: \"textile\", ext: [\"textile\"]},\n    {name: \"TiddlyWiki \", mime: \"text/x-tiddlywiki\", mode: \"tiddlywiki\"},\n    {name: \"Tiki wiki\", mime: \"text/tiki\", mode: \"tiki\"},\n    {name: \"TOML\", mime: \"text/x-toml\", mode: \"toml\", ext: [\"toml\"]},\n    {name: \"Tornado\", mime: \"text/x-tornado\", mode: \"tornado\"},\n    {name: \"troff\", mime: \"text/troff\", mode: \"troff\", ext: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]},\n    {name: \"TTCN\", mime: \"text/x-ttcn\", mode: \"ttcn\", ext: [\"ttcn\", \"ttcn3\", \"ttcnpp\"]},\n    {name: \"TTCN_CFG\", mime: \"text/x-ttcn-cfg\", mode: \"ttcn-cfg\", ext: [\"cfg\"]},\n    {name: \"Turtle\", mime: \"text/turtle\", mode: \"turtle\", ext: [\"ttl\"]},\n    {name: \"TypeScript\", mime: \"application/typescript\", mode: \"javascript\", ext: [\"ts\"], alias: [\"ts\"]},\n    {name: \"TypeScript-JSX\", mime: \"text/typescript-jsx\", mode: \"jsx\", ext: [\"tsx\"], alias: [\"tsx\"]},\n    {name: \"Twig\", mime: \"text/x-twig\", mode: \"twig\"},\n    {name: \"Web IDL\", mime: \"text/x-webidl\", mode: \"webidl\", ext: [\"webidl\"]},\n    {name: \"VB.NET\", mime: \"text/x-vb\", mode: \"vb\", ext: [\"vb\"]},\n    {name: \"VBScript\", mime: \"text/vbscript\", mode: \"vbscript\", ext: [\"vbs\"]},\n    {name: \"Velocity\", mime: \"text/velocity\", mode: \"velocity\", ext: [\"vtl\"]},\n    {name: \"Verilog\", mime: \"text/x-verilog\", mode: \"verilog\", ext: [\"v\"]},\n    {name: \"VHDL\", mime: \"text/x-vhdl\", mode: \"vhdl\", ext: [\"vhd\", \"vhdl\"]},\n    {name: \"Vue.js Component\", mimes: [\"script/x-vue\", \"text/x-vue\"], mode: \"vue\", ext: [\"vue\"]},\n    {name: \"XML\", mimes: [\"application/xml\", \"text/xml\"], mode: \"xml\", ext: [\"xml\", \"xsl\", \"xsd\", \"svg\"], alias: [\"rss\", \"wsdl\", \"xsd\"]},\n    {name: \"XQuery\", mime: \"application/xquery\", mode: \"xquery\", ext: [\"xy\", \"xquery\"]},\n    {name: \"Yacas\", mime: \"text/x-yacas\", mode: \"yacas\", ext: [\"ys\"]},\n    {name: \"YAML\", mimes: [\"text/x-yaml\", \"text/yaml\"], mode: \"yaml\", ext: [\"yaml\", \"yml\"], alias: [\"yml\"]},\n    {name: \"Z80\", mime: \"text/x-z80\", mode: \"z80\", ext: [\"z80\"]},\n    {name: \"mscgen\", mime: \"text/x-mscgen\", mode: \"mscgen\", ext: [\"mscgen\", \"mscin\", \"msc\"]},\n    {name: \"xu\", mime: \"text/x-xu\", mode: \"mscgen\", ext: [\"xu\"]},\n    {name: \"msgenny\", mime: \"text/x-msgenny\", mode: \"mscgen\", ext: [\"msgenny\"]}\n  ];\n  // Ensure all modes have a mime property for backwards compatibility\n  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n    var info = CodeMirror.modeInfo[i];\n    if (info.mimes) info.mime = info.mimes[0];\n  }\n\n  CodeMirror.findModeByMIME = function(mime) {\n    mime = mime.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.mime == mime) return info;\n      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)\n        if (info.mimes[j] == mime) return info;\n    }\n    if (/\\+xml$/.test(mime)) return CodeMirror.findModeByMIME(\"application/xml\")\n    if (/\\+json$/.test(mime)) return CodeMirror.findModeByMIME(\"application/json\")\n  };\n\n  CodeMirror.findModeByExtension = function(ext) {\n    ext = ext.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.ext) for (var j = 0; j < info.ext.length; j++)\n        if (info.ext[j] == ext) return info;\n    }\n  };\n\n  CodeMirror.findModeByFileName = function(filename) {\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.file && info.file.test(filename)) return info;\n    }\n    var dot = filename.lastIndexOf(\".\");\n    var ext = dot > -1 && filename.substring(dot + 1, filename.length);\n    if (ext) return CodeMirror.findModeByExtension(ext);\n  };\n\n  CodeMirror.findModeByName = function(name) {\n    name = name.toLowerCase();\n    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {\n      var info = CodeMirror.modeInfo[i];\n      if (info.name.toLowerCase() == name) return info;\n      if (info.alias) for (var j = 0; j < info.alias.length; j++)\n        if (info.alias[j].toLowerCase() == name) return info;\n    }\n  };\n});\n"],"sourceRoot":""}